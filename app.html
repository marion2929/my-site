<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>まりおんのサイト | AIアプリ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css" />
  <style>
    /* --- ページ内専用スタイル（グローバルを汚さない軽量版） --- */
    .app-wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
    .panel { background:#fff; border:1px solid #e5e7eb; border-radius:10px; box-shadow:0 2px 6px rgba(0,0,0,.06); padding:16px; margin-bottom:16px; }

  .btn-secondary {
    background:#6b7280;
    color:#fff;
    border:none;
    border-radius:8px;
    padding:10px 14px;
    font-weight:700;
    cursor:pointer;
  }
  .hint {
    color:#555;
    font-size:.95rem;
  }

    /* アップロード（DnD対応） */
    .dropzone {
      border: 2px dashed #4CAF50;
      border-radius: 12px;
      background: #f7fff8;
      padding: 20px;
      text-align: center;
      transition: background .2s, border-color .2s;
      cursor: pointer;
    }
    .dropzone.dragover { background:#ecfff0; border-color:#2ca04a; }
    .dropzone input[type="file"] { display: none; }
    .dropzone .hint { color:#555; font-size:.95rem; margin-top:6px; }

    /* 横スクロールのサムネリスト */
    .strip {
      display: flex; gap:12px;
      overflow-x: auto; padding: 8px 4px;
      scroll-snap-type: x mandatory;
    }
    .card {
      flex: 0 0 220px;
      border:1px solid #e5e7eb; border-radius:10px; overflow:hidden;
      background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.05);
      scroll-snap-align: start;
      display:flex; flex-direction:column;
    }
    .thumb {
      aspect-ratio: 16/9; background:#111; position:relative;
    }
    .thumb video {
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover;
    }
    .card .meta { padding:10px; display:flex; flex-direction:column; gap:8px; }
    .card .meta .name { font-size:.92rem; color:#333; word-break: break-all; }
    .card .meta .btn { background:#4CAF50; color:#fff; text-align:center; padding:8px 10px; border-radius:8px; font-weight:700; cursor:pointer; user-select:none; }
    .card .meta .btn:hover { filter: brightness(1.05); }

    /* 再生プレイヤー */
    .player {
      display: grid; grid-template-columns: 1fr;
      gap: 8px;
    }
    .player video {
      width: 100%; max-height: 60vh; background:#000; border-radius:12px;
    }
    .info-row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .badge { display:inline-block; background:#eef6ff; color:#0b57d0; border:1px solid #cfe2ff; padding:4px 8px; border-radius:8px; font-size:.9rem; }

    /* 後で追加するコントローラーの箱だけ用意（録音/同期/MIX） */
    .todo { padding:12px; border:1px dashed #d1d5db; color:#374151; background:#f9fafb; border-radius:8px; }
  </style>
</head>
<body>

  <!-- 共通ヘッダー（partials 方式） -->
  <div data-include="partials/header.html"></div>

  <main class="app-wrap">
    <h2 class="pop-font">動画に合わせて録音するツール（ステップ1：動画選択）</h2>

    <!-- 1) 動画アップロード（クリック & ドラッグ&ドロップ） -->
    <section class="panel">
      <h3>① 動画をアップロード</h3>
      <label class="dropzone" id="dropzone">
        <div><strong>ここをクリック</strong> または <strong>動画ファイルをドラッグ＆ドロップ</strong></div>
        <div class="hint">複数アップロード可 / ブラウザ内だけで処理されます</div>
        <input id="fileInput" type="file" accept="video/*" multiple />
      </label>
    </section>

    <!-- 2) アップ済み動画（横スクロールで並べる）＋「これを使う」ボタン -->
    <section class="panel">
      <h3>② アップした動画一覧</h3>
      <div class="strip" id="strip"></div>
      <div class="hint" style="color:#555; font-size:.95rem; margin-top:6px;">※ サムネは自動再生（ミュート）します。負荷が高い時は停止する場合があります。</div>
    </section>

    <!-- 3) 再生プレイヤー（選択反映） -->
    <section class="panel">
      <h3>③ 動画再生</h3>
      <div class="player">
        <video id="mainPlayer" controls playsinline></video>
        <div class="info-row">
          <span>選択中：</span>
          <span class="badge" id="selectedName">（未選択）</span>
        </div>
      </div>
    </section>

    <!-- 以降の機能は次ステップで追加予定（録音/同期/MIX/完成スロット） -->
    <section class="panel">
      <h3>④ 録音・同期・MIX（次のステップで実装）</h3>
      <div class="todo">
        ここに「録音ボタン」「同期再生」「MIX」「完成動画スロット（最大3つ）」のUIを順番に追加していきます。
<!-- ④ 録音（動画と同期再生） -->
<section class="panel">
  <h3>④ 録音（動画と同期）</h3>
  <div class="info-row" style="margin-bottom:8px;">
    <button id="micInit">マイク準備</button>
    <button id="recStart" disabled>● 録音開始</button>
    <button id="recStop" class="btn-secondary" disabled>■ 停止</button>
    <button id="recClear" class="btn-secondary" disabled>⟳ 録り直し</button>
    <span class="badge" id="recStatus">未録音</span>
  </div>

  <!-- 録音済み音声のプレビュー（同期ONのときは動画に追従） -->
  <div class="info-row">
    <label><input type="checkbox" id="syncToggle" checked> 動画と同期再生する</label>
    <audio id="voice" controls preload="metadata" style="flex:1;"></audio>
  </div>
  <p class="hint">※ 録音ボタンを押すと以前の録音はリセットされます。同期ONのときは動画の再生/一時停止/シーク/速度変更に音声が追従します。</p>
</section>

      </div>
    </section>
  </main>

  <footer>
    <p>© 2025 まりおん All rights reserved.</p>
  </footer>

  <!-- 共通ヘッダーの読み込み -->
  <script src="js/include.js" defer></script>

  <!-- ページ専用JS -->
  <script>
    // ------- 参照 -------
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const strip = document.getElementById('strip');
    const mainPlayer = document.getElementById('mainPlayer');
    const selectedName = document.getElementById('selectedName');

    // アップロード済み動画の管理（オブジェクトURLを保持）
    /** @type {{name:string, url:string, file:File}[]} */
    const videos = [];

    // ------- ファイル受付（クリック） -------
    dropzone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => {
      if (fileInput.files && fileInput.files.length) {
        handleFiles(fileInput.files);
        // 同じファイルを連続選択できるようにリセット
        fileInput.value = '';
      }
    });

    // ------- DnD 受付 -------
    ;['dragenter','dragover'].forEach(type => {
      dropzone.addEventListener(type, (e) => {
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.add('dragover');
      });
    });
    ;['dragleave','drop'].forEach(type => {
      dropzone.addEventListener(type, (e) => {
        e.preventDefault(); e.stopPropagation();
        dropzone.classList.remove('dragover');
      });
    });
    dropzone.addEventListener('drop', (e) => {
      const dt = e.dataTransfer;
      if (!dt) return;
      const files = Array.from(dt.files || []).filter(f => f.type.startsWith('video/'));
      if (files.length) handleFiles(files);
    });

    // ------- ファイル処理 -------
    function handleFiles(fileList) {
      const arr = Array.from(fileList);
      arr.forEach(file => {
        if (!file.type.startsWith('video/')) return;
        const url = URL.createObjectURL(file);
        videos.push({ name: file.name, url, file });
        appendCard({ name:file.name, url });
      });
      // 最初の追加時は自動選択
      if (!mainPlayer.src && videos.length) {
        selectVideo(0);
      }
    }

    // ------- サムネカードを作る -------
    function appendCard(item) {
      const idx = videos.length - 1;

      const card = document.createElement('div');
      card.className = 'card';

      const thumb = document.createElement('div');
      thumb.className = 'thumb';
      const v = document.createElement('video');
      v.src = item.url;
      v.muted = true; v.loop = true; v.playsInline = true;
      v.autoplay = true; // 自動でチラ見再生
      thumb.appendChild(v);

      const meta = document.createElement('div');
      meta.className = 'meta';
      const name = document.createElement('div');
      name.className = 'name';
      name.textContent = item.name;

      const btn = document.createElement('div');
      btn.className = 'btn';
      btn.textContent = 'これを使う';
      btn.addEventListener('click', () => selectVideo(idx));

      meta.appendChild(name);
      meta.appendChild(btn);

      card.appendChild(thumb);
      card.appendChild(meta);

      strip.appendChild(card);
    }

    // ------- 選択してメイン再生へ -------
    function selectVideo(index) {
      const item = videos[index];
      if (!item) return;
      // メインプレイヤーへ反映
      const wasPlaying = !mainPlayer.paused;
      const t = 0; // 選択時はとりあえず頭出し
      mainPlayer.src = item.url;
      mainPlayer.currentTime = t;
      selectedName.textContent = item.name;
      // 再生状態引き継ぎ（お好み）
      if (wasPlaying) mainPlayer.play().catch(()=>{});
    }

    // メモリ掃除（ページ離脱時に作ったURLを解放）
    window.addEventListener('beforeunload', () => {
      videos.forEach(v => URL.revokeObjectURL(v.url));
    });

// ===== ステップ2：録音 + 同期再生 =====
const micInitBtn = document.getElementById('micInit');
const recStartBtn = document.getElementById('recStart');
const recStopBtn  = document.getElementById('recStop');
const recClearBtn = document.getElementById('recClear');
const recStatus   = document.getElementById('recStatus');
const syncToggle  = document.getElementById('syncToggle');
const voice       = document.getElementById('voice');

let micStream = null;
let mediaRecorder = null;
let recChunks = [];
let voiceUrl = null;

// マイク初期化
micInitBtn.addEventListener('click', async () => {
  try {
    // すでに初期化済みなら何もしない
    if (micStream) { 
      micInitBtn.textContent = 'マイク準備済';
      micInitBtn.disabled = true;
      recStartBtn.disabled = false;
      return;
    }
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(micStream);
    mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) recChunks.push(e.data); };
    mediaRecorder.onstop = () => {
      // 前回の録音は破棄（上書き）
      if (voiceUrl) URL.revokeObjectURL(voiceUrl);
      const blob = new Blob(recChunks, { type: 'audio/webm' });
      recChunks = [];
      voiceUrl = URL.createObjectURL(blob);
      voice.src = voiceUrl;
      recStatus.textContent = '録音完了';
      recClearBtn.disabled = false;
    };
    micInitBtn.textContent = 'マイク準備済';
    micInitBtn.disabled = true;
    recStartBtn.disabled = false;
  } catch (e) {
    alert('マイクの初期化に失敗しました: ' + e.message);
  }
});

// 録音開始（前の録音は上書き）
recStartBtn.addEventListener('click', () => {
  if (!mediaRecorder) return;
  // 既存の録音があればクリア
  if (voiceUrl) { URL.revokeObjectURL(voiceUrl); voiceUrl = null; voice.removeAttribute('src'); }
  recChunks = [];
  try { mediaRecorder.start(100); } catch(_) { return; }
  recStatus.textContent = '録音中…';
  recStartBtn.disabled = true;
  recStopBtn.disabled = false;
  recClearBtn.disabled = true;
});

// 録音停止
recStopBtn.addEventListener('click', () => {
  if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
  mediaRecorder.stop();
  recStopBtn.disabled = true;
  recStartBtn.disabled = false;
});

// 録り直し（音声消去）
recClearBtn.addEventListener('click', () => {
  if (voiceUrl) { URL.revokeObjectURL(voiceUrl); voiceUrl = null; }
  voice.removeAttribute('src');
  recStatus.textContent = '未録音';
  recClearBtn.disabled = true;
});

// ===== 同期再生：動画(mainPlayer)に音声(voice)を追従させる =====
function bindSync() {
  const v = mainPlayer, a = voice;
  // 再生/一時停止
  v.addEventListener('play', () => {
    if (!syncToggle.checked || !a.src) return;
    a.playbackRate = v.playbackRate;
    a.currentTime = v.currentTime;
    a.play().catch(()=>{ /* ユーザー操作起点が必要な場合あり */ });
  });
  v.addEventListener('pause', () => {
    if (!syncToggle.checked || !a.src) return;
    a.pause();
  });
  // シーク・レート変更・終了
  v.addEventListener('seeking', () => {
    if (!syncToggle.checked || !a.src) return;
    a.currentTime = v.currentTime;
  });
  v.addEventListener('ratechange', () => {
    if (!syncToggle.checked || !a.src) return;
    a.playbackRate = v.playbackRate;
  });
  v.addEventListener('ended', () => {
    if (!syncToggle.checked || !a.src) return;
    a.pause();
    a.currentTime = 0;
  });

  // 同期ON/OFFを切り替えた瞬間の合わせ込み
  syncToggle.addEventListener('change', () => {
    if (!a.src) return;
    if (syncToggle.checked) {
      a.playbackRate = v.playbackRate;
      a.currentTime  = v.currentTime;
      if (!v.paused) a.play().catch(()=>{});
    } else {
      a.pause();
    }
  });
}
bindSync();

// 新しい動画を選んだ時、同期ONなら音声の位置も合わせる
function syncToHeadIfNeeded() {
  if (syncToggle.checked && voice.src) {
    voice.currentTime = mainPlayer.currentTime || 0;
    voice.playbackRate = mainPlayer.playbackRate || 1;
    if (!mainPlayer.paused) voice.play().catch(()=>{});
  }
}

// 既存の selectVideo を呼ぶ箇所の直後で呼ばれるように、フックしておく
const _selectVideoOriginal = selectVideo;
selectVideo = function(index) {
  _selectVideoOriginal(index);
  // 動画切替直後に位置合わせ
  syncToHeadIfNeeded();
};

  </script>
</body>
</html>
